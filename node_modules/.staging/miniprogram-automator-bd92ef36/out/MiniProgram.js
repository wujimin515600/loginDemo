"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const Page_1=__importDefault(require("./Page")),events_1=require("events"),util_1=require("./util"),cmpVersion_1=__importDefault(require("licia/cmpVersion")),endWith_1=__importDefault(require("licia/endWith")),isObj_1=__importDefault(require("licia/isObj")),pkg=require("../package.json");class MiniProgram extends events_1.EventEmitter{constructor(e){super(),this.pageMap=new Map,this.onLogAdded=(e=>{this.emit("console",e)}),this.onBindingCalled=(e=>{const{name:t,args:n}=e;try{const e=this.appBindings.get(t);e&&e(...n)}catch(e){}}),this.onExceptionThrown=(e=>{this.emit("exception",e)}),this.connection=e,this.connection.on("App.logAdded",this.onLogAdded),this.connection.on("App.bindingCalled",this.onBindingCalled),this.connection.on("App.exceptionThrown",this.onExceptionThrown),this.appBindings=new Map}async pageStack(){const{pageStack:e}=await this.send("App.getPageStack");return e.map(e=>Page_1.default.create(this.connection,{id:e.pageId,path:e.path,query:e.query},this.pageMap))}async navigateTo(e){return await this.changeRoute("navigateTo",e)}async redirectTo(e){return await this.changeRoute("redirectTo",e)}async navigateBack(){return await this.changeRoute("navigateBack")}async reLaunch(e){return await this.changeRoute("reLaunch",e)}async switchTab(e){return await this.changeRoute("switchTab",e)}async currentPage(){const{pageId:e,path:t,query:n}=await this.send("App.getCurrentPage");return Page_1.default.create(this.connection,{id:e,path:t,query:n},this.pageMap)}async systemInfo(){return await this.callWxMethod("getSystemInfoSync")}async callWxMethod(e,...t){return(await this.send("App.callWxMethod",{method:e,args:t})).result}async mockWxMethod(e,t){!endWith_1.default(e,"Sync")&&isObj_1.default(t)&&(t.errMsg||(t.errMsg=`${e}:ok`)),await this.send("App.mockWxMethod",{method:e,result:t})}async restoreWxMethod(e){await this.send("App.mockWxMethod",{method:e})}async evaluate(e,...t){const{result:n}=await this.send("App.callFunction",{functionDeclaration:e.toString(),args:t});return n}async pageScrollTo(e){await this.callWxMethod("pageScrollTo",{scrollTop:e,duration:0})}async close(){try{await this.send("App.exit")}catch(e){}await sleep(1e3),await this.send("Tool.close"),this.disconnect()}async remote(e=!1){const{qrCode:t}=await this.send("Tool.enableRemoteDebug",{auto:e});return t&&await util_1.printQrCode(await util_1.decodeQrCode(t)),new Promise(e=>{this.connection.once("Tool.onRemoteDebugConnected",async()=>{await sleep(1e3),e()})})}disconnect(){this.connection.dispose()}on(e,t){return"console"===e&&this.send("App.enableLog"),super.on(e,t),this}async exposeFunction(e,t){if(this.appBindings.has(e))throw Error(`Failed to expose function with name ${e}: already exists!`);this.appBindings.set(e,t),await this.send("App.addBinding",{name:e})}async checkVersion(){let e="";try{e=(await this.send("Tool.getInfo")).SDKVersion}catch(e){return}if("dev"!==e&&cmpVersion_1.default(e,"2.7.3")<0)throw Error(`SDKVersion is currently ${e}, while automator(${pkg.version}) requires at least version 2.7.3`)}async changeRoute(e,t){return await this.callWxMethod(e,{url:t}),await sleep(3e3),await this.currentPage()}async send(e,t={}){return await this.connection.send(e,t)}}function sleep(e){return new Promise(t=>setTimeout(t,e))}exports.default=MiniProgram;